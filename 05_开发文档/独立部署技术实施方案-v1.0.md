# 独立部署技术实施方案

**版本**：v1.0  
**创建日期**：2026-02-05  
**责任人**：技术团队  
**状态**：待实施

---

## 1. 整体架构设计

### 1.1 部署架构图

```
5个朋友独立实例架构：

┌─────────────────────────────────────────────────────┐
│                   云服务器（1台）                    │
│  4核8G，50元/月，Ubuntu 22.04                      │
├─────────────────────────────────────────────────────┤
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │朋友1实例│  │朋友2实例│  │朋友3实例│  │朋友4实例│ │
│  │ 8081端口│  │ 8082端口│  │ 8083端口│  │ 8084端口│ │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘ │
│          │          │          │          │        │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │朋友1数据│  │朋友2数据│  │朋友3数据│  │朋友4数据│ │
│  │ SQLite  │  │ SQLite  │  │ SQLite  │  │ SQLite  │ │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘ │
│                                                    │
│  ┌─────────┐                                        │
│  │朋友5实例│                                        │
│  │ 8085端口│                                        │
│  └─────────┘                                        │
│          │                                          │
│  ┌─────────┐                                        │
│  │朋友5数据│                                        │
│  │ SQLite  │                                        │
│  └─────────┘                                        │
└─────────────────────────────────────────────────────┘
```

### 1.2 技术栈选择

| 组件 | 技术选择 | 版本 | 选择理由 |
|------|----------|------|----------|
| **后端框架** | FastAPI | 0.109.0 | 开发速度快，自动API文档 |
| **前端框架** | React + TypeScript | React 18 | 生态丰富，Ant Design组件库 |
| **UI组件库** | Ant Design | 5.x | B端专业组件，开发效率高 |
| **数据库** | SQLite | 3.x | 单文件，无需安装配置 |
| **容器化** | Docker + Docker Compose | 最新版 | 一键部署，环境隔离 |
| **Web服务器** | Nginx | 1.24 | 反向代理，SSL配置 |
| **任务调度** | APScheduler | 3.10.4 | 轻量级定时任务 |

---

## 2. 项目结构设计

### 2.1 项目目录结构

```
loan-broker-system/
├── template/                     # 部署模板
│   ├── docker-compose.yml       # 容器编排模板
│   ├── Dockerfile               # Docker构建文件
│   ├── .env.template            # 环境变量模板
│   ├── nginx.conf.template      # Nginx配置模板
│   └── scripts/
│       ├── deploy.sh            # 部署脚本
│       ├── backup.sh            # 备份脚本
│       └── monitor.sh           # 监控脚本
├── source/                      # 源代码
│   ├── backend/
│   │   ├── app/
│   │   │   ├── main.py          # FastAPI入口
│   │   │   ├── config.py        # 配置管理
│   │   │   ├── database.py      # 数据库连接
│   │   │   ├── models/          # SQLAlchemy模型
│   │   │   ├── schemas/         # Pydantic模型
│   │   │   ├── api/             # API路由
│   │   │   ├── services/         # 业务逻辑
│   │   │   └── utils/           # 工具函数
│   │   ├── requirements.txt     # Python依赖
│   │   └── alembic/            # 数据库迁移
│   └── frontend/
│       ├── src/
│       │   ├── main.tsx         # 入口文件
│       │   ├── App.tsx          # 根组件
│       │   ├── api/             # API封装
│       │   ├── components/       # 组件
│       │   ├── pages/            # 页面
│       │   └── styles/           # 样式
│       ├── package.json         # Node依赖
│       ├── vite.config.ts       # Vite配置
│       └── tsconfig.json        # TypeScript配置
└── friends/                     # 朋友实例目录（部署时生成）
    ├── friend_张三/
    │   ├── docker-compose.yml   # 实例配置
    │   ├── .env                 # 实例环境变量
    │   ├── data/                # 数据目录
    │   │   ├── database.db      # SQLite数据库
    │   │   └── uploads/         # 上传文件
    │   └── logs/                # 日志目录
    ├── friend_李四/
    └── friend_王五/
```

### 2.2 Docker容器设计

**Dockerfile（后端）**：
```dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY backend/requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY backend/ .

# 创建数据目录
RUN mkdir -p /app/data/uploads

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**Dockerfile（前端）**：
```dockerfile
FROM node:18-alpine as build

WORKDIR /app

# 复制依赖文件
COPY frontend/package*.json .
RUN npm ci

# 复制源代码并构建
COPY frontend/ .
RUN npm run build

# 生产环境镜像
FROM nginx:alpine

# 复制构建产物
COPY --from=build /app/dist /usr/share/nginx/html

# 复制Nginx配置
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

**docker-compose.yml（实例模板）**：
```yaml
version: '3.8'

services:
  backend:
    build:
      context: ../source/backend
      dockerfile: Dockerfile
    container_name: ${APP_NAME:-friend}_backend
    ports:
      - "${PORT:-8000}:8000"
    volumes:
      - ./data:/app/data
      - ./logs/backend:/app/logs
    environment:
      - APP_NAME=${APP_NAME:-friend}
      - BRAND_NAME=${BRAND_NAME:-贷款助手}
      - LOGO_PATH=${LOGO_PATH:-/app/data/logo.png}
      - PRIMARY_COLOR=${PRIMARY_COLOR:-#1890ff}
      - DB_PATH=/app/data/database.db
      - UPLOAD_PATH=/app/data/uploads
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  frontend:
    build:
      context: ../source/frontend
      dockerfile: Dockerfile
    container_name: ${APP_NAME:-friend}_frontend
    ports:
      - "${FRONTEND_PORT:-3000}:80"
    depends_on:
      - backend
    restart: unless-stopped
```

---

## 3. 一键部署脚本详细实现

### 3.1 部署脚本（deploy_friend.sh）

```bash
#!/bin/bash
# 一键部署朋友实例脚本
# 用法：./deploy_friend.sh [朋友姓名] [子域名] [Logo路径]

set -e  # 遇到错误立即退出

# 参数检查
if [ $# -lt 2 ]; then
    echo "用法：$0 [朋友姓名] [子域名] [Logo路径(可选)]"
    echo "示例：$0 张三 friend1 /path/to/logo.png"
    exit 1
fi

FRIEND_NAME="$1"
FRIEND_SUBDOMAIN="$2"
LOGO_PATH="${3:-}"
INSTANCE_NAME="friend_${FRIEND_NAME}"
INSTANCE_DIR="friends/${INSTANCE_NAME}"

echo "🚀 开始部署 ${FRIEND_NAME} 的贷款助手系统..."
echo "实例名称：${INSTANCE_NAME}"
echo "子域名：${FRIEND_SUBDOMAIN}.yourdomain.com"

# 1. 创建实例目录
echo "📁 创建实例目录..."
mkdir -p "${INSTANCE_DIR}/data"
mkdir -p "${INSTANCE_DIR}/logs/backend"
mkdir -p "${INSTANCE_DIR}/logs/frontend"

# 2. 复制模板文件
echo "📄 复制模板文件..."
cp template/docker-compose.yml "${INSTANCE_DIR}/"
cp template/Dockerfile.backend "${INSTANCE_DIR}/Dockerfile.backend"
cp template/Dockerfile.frontend "${INSTANCE_DIR}/Dockerfile.frontend"

# 3. 创建环境变量文件
echo "⚙️ 创建环境变量配置..."
cat > "${INSTANCE_DIR}/.env" << EOF
# 朋友配置
APP_NAME=${FRIEND_NAME}
BRAND_NAME=${FRIEND_NAME}贷款助手
SUBDOMAIN=${FRIEND_SUBDOMAIN}
LOGO_PATH=${LOGO_PATH:-/app/data/logo.png}
PRIMARY_COLOR=#1890ff
SECONDARY_COLOR=#52c41a

# 数据库配置
DB_PATH=/app/data/database.db
UPLOAD_PATH=/app/data/uploads

# 服务器配置
PORT=8000
FRONTEND_PORT=3000
HOST=0.0.0.0
DEBUG=false

# 邮件配置（可选）
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=your_email@example.com
SMTP_PASSWORD=your_password
EOF

# 4. 复制Logo文件（如果有）
if [ -n "$LOGO_PATH" ] && [ -f "$LOGO_PATH" ]; then
    echo "🖼️ 复制Logo文件..."
    cp "$LOGO_PATH" "${INSTANCE_DIR}/data/logo.png"
else
    echo "⚠️ 未提供Logo文件，使用默认Logo"
    cp template/default_logo.png "${INSTANCE_DIR}/data/logo.png"
fi

# 5. 更新docker-compose.yml中的构建路径
echo "🔧 更新docker-compose配置..."
sed -i "s|../source/backend|./|g" "${INSTANCE_DIR}/docker-compose.yml"
sed -i "s|../source/frontend|./|g" "${INSTANCE_DIR}/docker-compose.yml"
sed -i "s|Dockerfile|Dockerfile.backend|g" "${INSTANCE_DIR}/docker-compose.yml"
sed -i "s|context: .|context: .\n      dockerfile: Dockerfile.frontend|g" "${INSTANCE_DIR}/docker-compose.yml"

# 6. 构建并启动容器
echo "🐳 构建Docker容器..."
cd "${INSTANCE_DIR}"
docker-compose build
docker-compose up -d

# 7. 等待服务启动
echo "⏳ 等待服务启动..."
sleep 10

# 8. 检查服务状态
echo "🔍 检查服务状态..."
if curl -f http://localhost:3000 > /dev/null 2>&1; then
    echo "✅ 前端服务启动成功！"
else
    echo "❌ 前端服务启动失败，请检查日志"
    docker-compose logs frontend
    exit 1
fi

if curl -f http://localhost:8000/health > /dev/null 2>&1; then
    echo "✅ 后端服务启动成功！"
else
    echo "❌ 后端服务启动失败，请检查日志"
    docker-compose logs backend
    exit 1
fi

# 9. 配置Nginx反向代理（如果需要）
if [ -n "$FRIEND_SUBDOMAIN" ]; then
    echo "🌐 配置Nginx反向代理..."
    NGINX_CONF="/etc/nginx/sites-available/${FRIEND_SUBDOMAIN}"
    
    cat > "$NGINX_CONF" << NGINX
server {
    listen 80;
    server_name ${FRIEND_SUBDOMAIN}.yourdomain.com;
    
    location / {
        proxy_pass http://localhost:3000;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
    
    location /api/ {
        proxy_pass http://localhost:8000;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}
NGINX

    # 创建符号链接并重载Nginx
    ln -sf "$NGINX_CONF" "/etc/nginx/sites-enabled/${FRIEND_SUBDOMAIN}"
    nginx -t && nginx -s reload
    
    echo "✅ Nginx配置完成！"
fi

# 10. 输出访问信息
echo ""
echo "🎉 部署完成！"
echo ""
echo "访问信息："
echo "  - 本地访问：http://localhost:3000"
if [ -n "$FRIEND_SUBDOMAIN" ]; then
    echo "  - 域名访问：http://${FRIEND_SUBDOMAIN}.yourdomain.com"
fi
echo ""
echo "默认账号："
echo "  - 用户名：admin"
echo "  - 密码：admin123（首次登录后请修改）"
echo ""
echo "管理命令："
echo "  - 查看日志：cd ${INSTANCE_DIR} && docker-compose logs -f"
echo "  - 重启服务：cd ${INSTANCE_DIR} && docker-compose restart"
echo "  - 停止服务：cd ${INSTANCE_DIR} && docker-compose down"
echo "  - 备份数据：cd ${INSTANCE_DIR} && ./scripts/backup.sh"
echo ""

# 11. 记录部署日志
DEPLOY_LOG="deployments.log"
echo "$(date '+%Y-%m-%d %H:%M:%S') - 部署 ${FRIEND_NAME} (${FRIEND_SUBDOMAIN})" >> "$DEPLOY_LOG"
```

### 3.2 备份脚本（backup.sh）

```bash
#!/bin/bash
# 数据备份脚本
# 用法：./backup.sh [朋友姓名]

set -e

FRIEND_NAME="${1:-}"
if [ -z "$FRIEND_NAME" ]; then
    echo "用法：$0 [朋友姓名]"
    exit 1
fi

INSTANCE_DIR="friends/friend_${FRIEND_NAME}"
BACKUP_DIR="backups/${FRIEND_NAME}"
DATE=$(date '+%Y%m%d_%H%M%S')

echo "📦 开始备份 ${FRIEND_NAME} 的数据..."

# 创建备份目录
mkdir -p "${BACKUP_DIR}"

# 停止服务（避免数据不一致）
cd "${INSTANCE_DIR}"
docker-compose stop backend

# 备份数据库
echo "💾 备份数据库..."
cp data/database.db "${BACKUP_DIR}/database_${DATE}.db"

# 备份上传文件
echo "📁 备份上传文件..."
tar -czf "${BACKUP_DIR}/uploads_${DATE}.tar.gz" data/uploads/

# 备份日志
echo "📝 备份日志..."
tar -czf "${BACKUP_DIR}/logs_${DATE}.tar.gz" logs/

# 重新启动服务
docker-compose start backend

echo "✅ 备份完成！"
echo "备份文件："
echo "  - ${BACKUP_DIR}/database_${DATE}.db"
echo "  - ${BACKUP_DIR}/uploads_${DATE}.tar.gz"
echo "  - ${BACKUP_DIR}/logs_${DATE}.tar.gz"
```

### 3.3 监控脚本（monitor.sh）

```bash
#!/bin/bash
# 监控脚本
# 用法：./monitor.sh [朋友姓名]

set -e

FRIEND_NAME="${1:-}"
if [ -z "$FRIEND_NAME" ]; then
    INSTANCES=$(ls -d friends/friend_* 2>/dev/null | xargs -n1 basename | sed 's/friend_//')
    
    echo "📊 所有实例监控状态："
    echo ""
    
    for INSTANCE in $INSTANCES; do
        ./monitor.sh "$INSTANCE" --quiet
    done
    
    exit 0
fi

INSTANCE_DIR="friends/friend_${FRIEND_NAME}"
QUIET="$2"

if [ ! -d "$INSTANCE_DIR" ]; then
    echo "❌ 实例 ${FRIEND_NAME} 不存在"
    exit 1
fi

cd "$INSTANCE_DIR"

# 检查容器状态
BACKEND_STATUS=$(docker-compose ps backend --format "{{.Status}}")
FRONTEND_STATUS=$(docker-compose ps frontend --format "{{.Status}}")

# 检查服务健康状态
BACKEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health || echo "000")
FRONTEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 || echo "000")

# 检查磁盘使用
DISK_USAGE=$(df -h data/ | tail -1 | awk '{print $5}')
DATABASE_SIZE=$(du -h data/database.db | awk '{print $1}')

# 检查日志大小
LOG_SIZE=$(du -h logs/ | tail -1 | awk '{print $1}')

if [ "$QUIET" != "--quiet" ]; then
    echo "📊 ${FRIEND_NAME} 监控状态："
    echo ""
    echo "🔧 容器状态："
    echo "  - 后端：${BACKEND_STATUS}"
    echo "  - 前端：${FRONTEND_STATUS}"
    echo ""
    echo "💓 健康检查："
    echo "  - 后端API：${BACKEND_HEALTH} (200为正常)"
    echo "  - 前端页面：${FRONTEND_HEALTH} (200为正常)"
    echo ""
    echo "💾 存储状态："
    echo "  - 磁盘使用率：${DISK_USAGE}"
    echo "  - 数据库大小：${DATABASE_SIZE}"
    echo "  - 日志大小：${LOG_SIZE}"
    echo ""
else
    # 安静模式，只输出关键信息
    if [ "$BACKEND_HEALTH" = "200" ] && [ "$FRONTEND_HEALTH" = "200" ]; then
        echo "✅ ${FRIEND_NAME}: 健康"
    else
        echo "❌ ${FRIEND_NAME}: 异常（后端:${BACKEND_HEALTH}, 前端:${FRONTEND_HEALTH}）"
    fi
fi
```

---

## 4. 数据库设计（简化版）

### 4.1 核心表结构

```sql
-- 租户表（每个朋友一个租户）
CREATE TABLE tenants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,           -- 朋友姓名
    subdomain TEXT UNIQUE,              -- 子域名
    logo_path TEXT,                     -- Logo路径
    primary_color TEXT DEFAULT '#1890ff',
    secondary_color TEXT DEFAULT '#52c41a',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 客户表
CREATE TABLE customers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tenant_id INTEGER NOT NULL,
    name TEXT NOT NULL,                 -- 企业名称
    reg_capital REAL,                   -- 注册资本（万元）
    established_date DATE,               -- 成立时间
    legal_person TEXT,                  -- 法人姓名
    annual_invoice REAL,                 -- 年开票（万元）
    annual_tax REAL,                    -- 年纳税（万元）
    monthly_flow REAL,                   -- 对公流水月均（万元）
    legal_credit TEXT,                  -- 法人征信
    company_credit TEXT,                 -- 企业征信
    main_business TEXT,                 -- 主营业务
    industry TEXT,                      -- 行业
    loan_demand REAL,                   -- 贷款需求（万元）
    collateral TEXT,                     -- 抵押物情况
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);

-- 诊断记录表
CREATE TABLE diagnosis_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tenant_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    flow_score INTEGER,                 -- 流水体质得分
    invoice_tax_score INTEGER,          -- 票税体质得分
    credit_score INTEGER,               -- 征信体质得分
    asset_score INTEGER,                -- 资产体质得分
    qualification_score INTEGER,        -- 资质体质得分
    industry_score INTEGER,             -- 行业体质得分
    total_score INTEGER,                -- 总分
    category TEXT CHECK(category IN ('A', 'B', 'C')),  -- A/B/C分类
    diagnosis_reason TEXT,              -- 诊断理由
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);

-- 改造方案表
CREATE TABLE improvement_plans (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tenant_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    diagnosis_id INTEGER NOT NULL,
    plan_type TEXT,                     -- 方案类型（开票提升、纳税提升等）
    gap_description TEXT,               -- 缺口描述
    task_list TEXT,                     -- 任务清单（JSON格式）
    service_provider_recommendation TEXT, -- 服务商推荐
    estimated_cost REAL,                -- 预估成本
    estimated_loan_increase REAL,       -- 预估贷款增加额
    status TEXT DEFAULT 'pending',      -- 状态（pending/in_progress/completed）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (customer_id) REFERENCES customers(id),
    FOREIGN KEY (diagnosis_id) REFERENCES diagnosis_records(id)
);

-- 操作日志表（简化版）
CREATE TABLE operation_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tenant_id INTEGER NOT NULL,
    user_id INTEGER,                    -- 操作人（暂时只有admin）
    action TEXT NOT NULL,               -- 操作类型
    resource_type TEXT,                 -- 资源类型
    resource_id INTEGER,               -- 资源ID
    details TEXT,                       -- 操作详情
    ip_address TEXT,                    -- IP地址
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);
```

### 4.2 数据库初始化脚本

```python
# backend/scripts/init_db.py
import sqlite3
import os
from pathlib import Path

def init_database(db_path):
    """初始化数据库"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # 读取SQL文件
    sql_file = Path(__file__).parent.parent / 'database' / 'schema.sql'
    with open(sql_file, 'r', encoding='utf-8') as f:
        schema_sql = f.read()
    
    # 执行SQL
    cursor.executescript(schema_sql)
    
    # 创建默认租户（admin）
    cursor.execute('''
    INSERT INTO tenants (name, subdomain, logo_path) 
    VALUES (?, ?, ?)
    ''', ('admin', 'admin', '/app/data/default_logo.png'))
    
    # 创建默认管理员账号
    cursor.execute('''
    INSERT INTO users (tenant_id, username, password_hash, role) 
    VALUES (?, ?, ?, ?)
    ''', (1, 'admin', 'hashed_password', 'admin'))
    
    conn.commit()
    conn.close()
    print(f"✅ 数据库初始化完成：{db_path}")

def create_tenant_database(tenant_name, db_path):
    """为租户创建数据库"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # 创建租户记录
    cursor.execute('''
    INSERT INTO tenants (name) VALUES (?)
    ''', (tenant_name,))
    
    tenant_id = cursor.lastrowid
    
    # 为租户创建管理员账号
    cursor.execute('''
    INSERT INTO users (tenant_id, username, password_hash, role) 
    VALUES (?, ?, ?, ?)
    ''', (tenant_id, 'admin', 'hashed_password', 'admin'))
    
    conn.commit()
    conn.close()
    print(f"✅ 租户 {tenant_name} 创建完成，ID: {tenant_id}")
    return tenant_id

if __name__ == '__main__':
    # 初始化主数据库
    init_database('data/database.db')
    
    # 示例：为朋友创建数据库
    # create_tenant_database('张三', 'data/friend_zhangsan.db')
```

---

## 5. 环境配置与部署

### 5.1 服务器配置要求

**最低配置**：
- CPU：2核
- 内存：4GB
- 存储：50GB
- 系统：Ubuntu 22.04 LTS
- 网络：公网IP，开放80/443端口

**推荐配置**：
- CPU：4核
- 内存：8GB
- 存储：100GB
- 系统：Ubuntu 22.04 LTS
- 网络：公网IP，域名解析

### 5.2 环境安装脚本

```bash
#!/bin/bash
# 服务器环境安装脚本
# 用法：在干净的Ubuntu 22.04服务器上运行

set -e

echo "🔧 开始安装贷款助手系统运行环境..."

# 1. 更新系统
echo "🔄 更新系统包..."
apt-get update && apt-get upgrade -y

# 2. 安装Docker
echo "🐳 安装Docker..."
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh
rm get-docker.sh

# 3. 安装Docker Compose
echo "📦 安装Docker Compose..."
curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

# 4. 安装Nginx（用于反向代理）
echo "🌐 安装Nginx..."
apt-get install -y nginx

# 5. 配置防火墙
echo "🛡️ 配置防火墙..."
ufw allow 22/tcp  # SSH
ufw allow 80/tcp  # HTTP
ufw allow 443/tcp # HTTPS
ufw --force enable

# 6. 创建应用目录
echo "📁 创建应用目录..."
mkdir -p /opt/loan-broker
mkdir -p /opt/loan-broker/friends
mkdir -p /opt/loan-broker/backups
mkdir -p /opt/loan-broker/logs

# 7. 设置权限
echo "🔐 设置权限..."
chown -R $USER:$USER /opt/loan-broker

# 8. 下载部署脚本
echo "📥 下载部署脚本..."
cd /opt/loan-broker
git clone <repository_url> .
chmod +x scripts/*.sh

echo ""
echo "✅ 环境安装完成！"
echo ""
echo "下一步："
echo "1. 配置域名解析（将域名指向本机IP）"
echo "2. 运行部署脚本：./scripts/deploy_friend.sh [朋友姓名] [子域名]"
echo "3. 配置SSL证书（建议使用Let's Encrypt）"
echo ""
```

### 5.3 SSL证书配置（Let's Encrypt）

```bash
#!/bin/bash
# SSL证书配置脚本
# 用法：./setup_ssl.sh [域名]

set -e

DOMAIN="$1"
if [ -z "$DOMAIN" ]; then
    echo "用法：$0 [域名]"
    echo "示例：$0 friend1.yourdomain.com"
    exit 1
fi

echo "🔐 为 ${DOMAIN} 配置SSL证书..."

# 1. 安装Certbot
apt-get install -y certbot python3-certbot-nginx

# 2. 获取证书
certbot --nginx -d "$DOMAIN" --non-interactive --agree-tos --email admin@yourdomain.com

# 3. 配置自动续期
echo "0 0 * * * certbot renew --quiet" | crontab -

echo "✅ SSL证书配置完成！"
echo "访问 https://${DOMAIN} 测试"
```

---

## 6. 监控与维护

### 6.1 系统监控面板

```python
# backend/app/monitoring.py
from fastapi import APIRouter
from datetime import datetime, timedelta
import psutil
import sqlite3
import os

router = APIRouter()

@router.get("/health")
async def health_check():
    """健康检查端点"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "version": "1.0.0"
    }

@router.get("/metrics")
async def system_metrics():
    """系统指标"""
    # CPU使用率
    cpu_percent = psutil.cpu_percent(interval=1)
    
    # 内存使用率
    memory = psutil.virtual_memory()
    
    # 磁盘使用率
    disk = psutil.disk_usage('/')
    
    # 数据库连接数
    db_path = os.getenv('DB_PATH', 'data/database.db')
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT COUNT(*) FROM sqlite_master")
        table_count = cursor.fetchone()[0]
        conn.close()
    except:
        table_count = 0
    
    return {
        "cpu_percent": cpu_percent,
        "memory_percent": memory.percent,
        "disk_percent": disk.percent,
        "database_tables": table_count,
        "timestamp": datetime.now().isoformat()
    }

@router.get("/logs")
async def get_logs(limit: int = 100):
    """获取最近的操作日志"""
    db_path = os.getenv('DB_PATH', 'data/database.db')
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    cursor.execute('''
    SELECT action, resource_type, details, created_at 
    FROM operation_logs 
    ORDER BY created_at DESC 
    LIMIT ?
    ''', (limit,))
    
    logs = cursor.fetchall()
    conn.close()
    
    return {
        "logs": [
            {
                "action": log[0],
                "resource_type": log[1],
                "details": log[2],
                "created_at": log[3]
            }
            for log in logs
        ]
    }
```

### 6.2 每日维护脚本

```bash
#!/bin/bash
# 每日维护脚本
# 用法：添加到crontab，每天凌晨3点执行

set -e

echo "🔄 $(date) - 开始每日维护..."

# 1. 备份所有实例
echo "💾 备份所有实例..."
for INSTANCE_DIR in friends/friend_*; do
    if [ -d "$INSTANCE_DIR" ]; then
        FRIEND_NAME=$(basename "$INSTANCE_DIR" | sed 's/friend_//')
        cd "$INSTANCE_DIR"
        ../scripts/backup.sh "$FRIEND_NAME"
        cd -
    fi
done

# 2. 清理旧备份（保留最近7天）
echo "🧹 清理旧备份..."
find backups -name "*.db" -mtime +7 -delete
find backups -name "*.tar.gz" -mtime +7 -delete

# 3. 清理日志（保留最近30天）
echo "📝 清理日志..."
find friends/friend_*/logs -name "*.log" -mtime +30 -delete

# 4. 检查磁盘空间
echo "💾 检查磁盘空间..."
df -h /

# 5. 重启异常容器
echo "🔄 检查并重启异常容器..."
for INSTANCE_DIR in friends/friend_*; do
    if [ -d "$INSTANCE_DIR" ]; then
        cd "$INSTANCE_DIR"
        
        # 检查后端健康状态
        if ! curl -f http://localhost:8000/health > /dev/null 2>&1; then
            echo "⚠️ 重启异常容器：$(basename "$INSTANCE_DIR")"
            docker-compose restart backend
        fi
        
        # 检查前端健康状态
        if ! curl -f http://localhost:3000 > /dev/null 2>&1; then
            echo "⚠️ 重启异常容器：$(basename "$INSTANCE_DIR")"
            docker-compose restart frontend
        fi
        
        cd -
    fi
done

echo "✅ $(date) - 每日维护完成！"
```

### 6.3 监控告警配置

```bash
#!/bin/bash
# 监控告警脚本
# 用法：添加到crontab，每5分钟执行一次

set -e

# 告警阈值
CPU_THRESHOLD=80
MEMORY_THRESHOLD=85
DISK_THRESHOLD=90

# 获取系统指标
CPU_PERCENT=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
MEMORY_PERCENT=$(free | grep Mem | awk '{print $3/$2 * 100.0}')
DISK_PERCENT=$(df -h / | tail -1 | awk '{print $5}' | sed 's/%//')

# CPU告警
if (( $(echo "$CPU_PERCENT > $CPU_THRESHOLD" | bc -l) )); then
    echo "🚨 CPU使用率过高：${CPU_PERCENT}%"
    # 这里可以发送邮件或短信告警
fi

# 内存告警
if (( $(echo "$MEMORY_PERCENT > $MEMORY_THRESHOLD" | bc -l) )); then
    echo "🚨 内存使用率过高：${MEMORY_PERCENT}%"
    # 这里可以发送邮件或短信告警
fi

# 磁盘告警
if (( $(echo "$DISK_PERCENT > $DISK_THRESHOLD" | bc -l) )); then
    echo "🚨 磁盘使用率过高：${DISK_PERCENT}%"
    # 这里可以发送邮件或短信告警
fi

# 检查每个实例
for INSTANCE_DIR in friends/friend_*; do
    if [ -d "$INSTANCE_DIR" ]; then
        FRIEND_NAME=$(basename "$INSTANCE_DIR" | sed 's/friend_//')
        
        cd "$INSTANCE_DIR"
        
        # 检查后端服务
        if ! curl -f http://localhost:8000/health > /dev/null 2>&1; then
            echo "🚨 实例 ${FRIEND_NAME} 后端服务异常"
            # 发送告警
        fi
        
        # 检查前端服务
        if ! curl -f http://localhost:3000 > /dev/null 2>&1; then
            echo "🚨 实例 ${FRIEND_NAME} 前端服务异常"
            # 发送告警
        fi
        
        cd -
    fi
done
```

---

## 7. 成本预算

### 7.1 初始成本（一次性）

| 项目 | 单价 | 数量 | 总价 | 备注 |
|------|------|------|------|------|
| **云服务器** | 50元/月 | 1台 | 50元/月 | 4核8G，按年付有优惠 |
| **域名注册** | 60元/年 | 1个 | 60元/年 | 主域名 |
| **子域名** | 0元 | 5个 | 0元 | 无需额外费用 |
| **SSL证书** | 0元 | 5个 | 0元 | Let's Encrypt免费 |
| **总计** | - | - | **110元** | 首月投入 |

### 7.2 月度运营成本

| 项目 | 单价 | 数量 | 月成本 | 年成本 |
|------|------|------|--------|--------|
| **云服务器** | 50元/月 | 1台 | 50元 | 600元 |
| **域名续费** | 60元/年 | 1个 | 5元 | 60元 |
| **监控服务** | 0元 | - | 0元 | 0元 |
| **备份存储** | 0元 | - | 0元 | 0元 |
| **总计** | - | - | **55元/月** | **660元/年** |

### 7.3 人力成本估算

| 阶段 | 任务 | 时间投入 | 人员 |
|------|------|----------|------|
| **Week 1-2** | V0开发 | 80小时 | 开发1人 |
| **Week 3** | 朋友1部署 | 8小时 | 运维+产品 |
| **Week 4** | 修复+朋友2-3部署 | 16小时 | 开发+运维 |
| **Week 5-6** | 数据分析+优化 | 16小时 | 产品 |
| **Week 7-8** | 朋友4-5部署+复盘 | 24小时 | 全员 |
| **Week 9-13** | 日常维护 | 20小时 | 运维 |
| **总计** | - | **164小时** | - |

---

## 8. 安全考虑

### 8.1 数据安全

1. **数据库隔离**：每个朋友独立SQLite文件
2. **文件上传限制**：限制文件类型和大小
3. **SQL注入防护**：使用SQLAlchemy ORM，参数化查询
4. **XSS防护**：React自动转义，后端输入验证

### 8.2 访问安全

1. **强密码策略**：默认密码强制修改
2. **HTTPS加密**：所有流量SSL加密
3. **IP白名单**：可选配置，限制访问IP
4. **会话管理**：JWT token，设置合理过期时间

### 8.3 备份策略

1. **每日自动备份**：凌晨3点自动备份
2. **保留7天**：保留最近7天备份
3. **异地备份**：可选配置，备份到其他存储
4. **恢复测试**：每月测试一次恢复流程

### 8.4 监控告警

1. **健康检查**：每5分钟检查服务状态
2. **资源监控**：CPU/内存/磁盘监控
3. **错误告警**：服务异常自动告警
4. **日志审计**：所有操作记录日志

---

## 9. 扩展性考虑

### 9.1 垂直扩展（单个实例）

当单个朋友实例负载增加时：
1. **增加容器资源**：调整Docker容器CPU/内存限制
2. **数据库优化**：SQLite → PostgreSQL迁移
3. **缓存层**：添加Redis缓存
4. **CDN加速**：静态资源CDN加速

### 9.2 水平扩展（更多朋友）

当朋友数量增加时：
1. **服务器升级**：升级云服务器配置
2. **负载均衡**：添加负载均衡器
3. **自动化部署**：完善部署脚本
4. **监控体系**：建立完整的监控体系

### 9.3 功能扩展

V0.1计划功能：
1. **多租户SaaS**：从独立部署迁移到多租户
2. **复杂合规**：添加委托协议、审计日志
3. **分佣功能**：添加返佣披露和对账
4. **移动端适配**：响应式设计，移动端优化

---

## 10. 实施步骤

### 10.1 准备工作

1. **购买云服务器**（阿里云/腾讯云）
2. **注册域名**（yourdomain.com）
3. **配置域名解析**（A记录指向服务器IP）
4. **准备朋友信息**（5个朋友的姓名、Logo）
5. **准备客户数据**（每个朋友50+客户数据）

### 10.2 部署时间表

**Day 1**：
- 运行环境安装脚本
- 部署脚本测试
- 朋友1环境准备

**Day 2**：
- 朋友1系统部署
- 导入客户数据
- 基础培训

**Day 3-7**：
- 朋友1使用观察
- 收集第1周反馈
- 问题修复

**Day 8**：
- 部署朋友2、朋友3
- 同步修复的版本

**Day 9-14**：
- 朋友2-3使用观察
- 数据分析
- 准备朋友4-5部署

**Day 15**：
- 部署朋友4、朋友5
- 完整数据收集启动

### 10.3 验收标准

**技术验收**：
- ✅ 5个实例独立运行
- ✅ 一键部署脚本正常工作
- ✅ 备份恢复流程验证通过
- ✅ 监控告警正常工作

**功能验收**：
- ✅ 10项核心功能可用
- ✅ 数据导入导出正常
- ✅ 诊断分层准确
- ✅ 方案生成可用

**业务验收**：
- ✅ 5个朋友系统正常运行
- ✅ 朋友能独立使用核心功能
- ✅ 朋友反馈问题能快速响应
- ✅ 使用数据能自动收集

---

## 11. 常见问题解答

### Q1：为什么选择独立部署而不是多租户？

**A1**：
1. **数据安全**：朋友更信任数据在自己手里
2. **完全隔离**：一个朋友的问题不影响其他朋友
3. **品牌独立**：每个朋友有自己的品牌体验
4. **成本可控**：5个容器，每月250元
5. **灵活性高**：可以按朋友需求定制

### Q2：SQLite能支撑多少数据？

**A2**：
- **单个朋友**：支持1000-5000个客户记录
- **并发用户**：支持10-20个并发用户
- **性能表现**：100条数据导入<5秒，诊断计算<2秒
- **扩展计划**：V1升级到PostgreSQL

### Q3：如何保证数据备份安全？

**A3**：
1. **每日自动备份**：凌晨3点自动执行
2. **保留7天备份**：滚动备份，保留最近7天
3. **异地备份选项**：可配置备份到OSS/COS
4. **恢复测试**：每月测试一次恢复流程

### Q4：朋友需要懂技术吗？

**A4**：
- **不需要**：系统提供完整的一键部署
- **培训**：30分钟基础培训即可上手
- **支持**：提供7x24小时技术支持
- **文档**：详细的用户手册和视频教程

### Q5：系统宕机怎么办？

**A5**：
1. **自动恢复**：Docker容器自动重启
2. **监控告警**：5分钟健康检查，异常告警
3. **快速响应**：1小时内响应，4小时内修复
4. **数据安全**：每日备份，数据不丢失

---

## 12. 联系方式与支持

### 技术支持
- **紧急问题**：微信/电话直接联系
- **一般问题**：24小时内响应
- **功能建议**：每周收集一次
- **bug反馈**：24小时内确认，3天内修复

### 文档与培训
- **用户手册**：在线文档 + 视频教程
- **培训材料**：30分钟快速上手教程
- **常见问题**：FAQ文档
- **更新日志**：功能更新通知

### 版本更新
- **bug修复**：随时发布
- **小功能**：每周一次
- **大功能**：每月一次
- **版本通知**：更新前1天通知

---

**文档版本**：v1.0  
**创建日期**：2026-02-05  
**维护人**：技术团队  
**下次评审**：部署前技术评审